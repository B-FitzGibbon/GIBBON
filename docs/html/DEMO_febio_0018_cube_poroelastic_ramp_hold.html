
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>DEMO_febio_0018_cube_poroelastic_ramp_hold</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-06-04"><meta name="DC.source" content="DEMO_febio_0018_cube_poroelastic_ramp_hold.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>DEMO_febio_0018_cube_poroelastic_ramp_hold</h1><!--introduction--><p>Below is a demonstration for:</p><div><ul><li>Building geometry for a cube with hexahedral elements</li><li>Defining the boundary conditions</li><li>Coding the febio structure</li><li>Running the model</li><li>Importing and visualizing the displacement and stress results</li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Keywords</a></li><li><a href="#3">Plot settings</a></li><li><a href="#4">Control parameters</a></li><li><a href="#5">Creating model geometry and mesh</a></li><li><a href="#7">Defining the boundary conditions</a></li><li><a href="#9">Defining the FEBio input structure</a></li><li><a href="#10">Quick viewing of the FEBio input file structure</a></li><li><a href="#12">Exporting the FEBio input file</a></li><li><a href="#13">Running the FEBio analysis</a></li><li><a href="#14">Import FEBio results</a></li></ul></div><h2 id="1">Keywords</h2><div><ul><li>febio_spec version 2.5</li><li>febio, FEBio</li><li>uniaxial loading</li><li>compression, tension, compressive, tensile</li><li>displacement control, displacement boundary condition</li><li>hexahedral elements, hex8</li><li>cube, box, rectangular</li><li>static, solid</li><li>hyperelastic, Ogden</li><li>viscoelastic</li><li>poroelastic</li><li>biphasic</li><li>uncoupled, coupled</li><li>ramp hold</li><li>displacement logfile</li><li>stress logfile</li></ul></div><pre class="codeinput">clear; close <span class="string">all</span>; clc;
</pre><h2 id="3">Plot settings</h2><pre class="codeinput">fontSize=20;
faceAlpha1=0.8;
markerSize=40;
lineWidth=3;
</pre><h2 id="4">Control parameters</h2><pre class="codeinput"><span class="comment">% Path names</span>
defaultFolder = fileparts(fileparts(mfilename(<span class="string">'fullpath'</span>)));
savePath=fullfile(defaultFolder,<span class="string">'data'</span>,<span class="string">'temp'</span>);

<span class="comment">% Defining file names</span>
febioFebFileNamePart=<span class="string">'tempModel'</span>;
febioFebFileName=fullfile(savePath,[febioFebFileNamePart,<span class="string">'.feb'</span>]); <span class="comment">%FEB file name</span>
febioLogFileName=fullfile(savePath,[febioFebFileNamePart,<span class="string">'.txt'</span>]); <span class="comment">%FEBio log file name</span>
febioLogFileName_disp=[febioFebFileNamePart,<span class="string">'_disp_out.txt'</span>]; <span class="comment">%Log file name for exporting displacement</span>
febioLogFileName_force=[febioFebFileNamePart,<span class="string">'_force_out.txt'</span>]; <span class="comment">%Log file name for exporting force</span>
febioLogFileName_stress=[febioFebFileNamePart,<span class="string">'_stress_out.txt'</span>]; <span class="comment">%Log file name for exporting stress</span>

<span class="comment">%Specifying dimensions and number of elements</span>
meshType=<span class="string">'hex8'</span>; <span class="comment">%hex8 or tet4</span>
unitSystem=2; <span class="comment">%1=m, 2=mm</span>
<span class="keyword">switch</span> unitSystem
    <span class="keyword">case</span> 1
        min_residual=1e-40;
        cubeSize=10e-3;
        sampleWidth=cubeSize; <span class="comment">%Width</span>
        sampleThickness=cubeSize; <span class="comment">%Thickness</span>
        sampleHeight=cubeSize; <span class="comment">%Height</span>
        pointSpacings=2e-3*ones(1,3); <span class="comment">%Desired point spacing between nodes</span>
        numElementsWidth=round(sampleWidth/pointSpacings(1)); <span class="comment">%Number of elemens in dir 1</span>
        numElementsThickness=round(sampleThickness/pointSpacings(2)); <span class="comment">%Number of elemens in dir 2</span>
        numElementsHeight=round(sampleHeight/pointSpacings(3)); <span class="comment">%Number of elemens in dir 3</span>

        <span class="comment">%Define applied displacement</span>
        appliedStrain=0.3; <span class="comment">%Linear strain (Only used to compute applied stretch)</span>
        loadingOption=<span class="string">'compression'</span>; <span class="comment">% or 'tension'</span>
        <span class="keyword">switch</span> loadingOption
            <span class="keyword">case</span> <span class="string">'compression'</span>
                stretchLoad=1-appliedStrain; <span class="comment">%The applied stretch for uniaxial loading</span>
            <span class="keyword">case</span> <span class="string">'tension'</span>
                stretchLoad=1+appliedStrain; <span class="comment">%The applied stretch for uniaxial loading</span>
        <span class="keyword">end</span>
        displacementMagnitude=(stretchLoad*sampleHeight)-sampleHeight; <span class="comment">%The displacement magnitude</span>

        <span class="comment">%Material parameter set</span>

        <span class="comment">%Hyperelastic parameters</span>
        c1=1000; <span class="comment">%ogden c1</span>
        m1=6; <span class="comment">%ogden m1</span>
        k_factor=1; <span class="comment">%Bulk like modulus factor</span>
        k=c1*k_factor; <span class="comment">%The bulk like modulus</span>

        d=1000; <span class="comment">%Density</span>

        <span class="comment">%Constant Isotropic Permeability parameters</span>
        phi0=0.5; <span class="comment">%Solid volume fraction in reference configuration</span>
        permHydro=7.41e-11; <span class="comment">%hydraulic permeability</span>
    <span class="keyword">case</span> 2
        min_residual=1e-40;
        cubeSize=10;
        sampleWidth=cubeSize; <span class="comment">%Width</span>
        sampleThickness=cubeSize; <span class="comment">%Thickness</span>
        sampleHeight=cubeSize; <span class="comment">%Height</span>
        pointSpacings=2*ones(1,3); <span class="comment">%Desired point spacing between nodes</span>
        numElementsWidth=round(sampleWidth/pointSpacings(1)); <span class="comment">%Number of elemens in dir 1</span>
        numElementsThickness=round(sampleThickness/pointSpacings(2)); <span class="comment">%Number of elemens in dir 2</span>
        numElementsHeight=round(sampleHeight/pointSpacings(3)); <span class="comment">%Number of elemens in dir 3</span>

        <span class="comment">%Define applied displacement</span>
        appliedStrain=0.3; <span class="comment">%Linear strain (Only used to compute applied stretch)</span>
        loadingOption=<span class="string">'compression'</span>; <span class="comment">% or 'tension'</span>
        <span class="keyword">switch</span> loadingOption
            <span class="keyword">case</span> <span class="string">'compression'</span>
                stretchLoad=1-appliedStrain; <span class="comment">%The applied stretch for uniaxial loading</span>
            <span class="keyword">case</span> <span class="string">'tension'</span>
                stretchLoad=1+appliedStrain; <span class="comment">%The applied stretch for uniaxial loading</span>
        <span class="keyword">end</span>
        displacementMagnitude=(stretchLoad*sampleHeight)-sampleHeight; <span class="comment">%The displacement magnitude</span>

        <span class="comment">%Material parameter set</span>

        <span class="comment">%Hyperelastic parameters</span>
        c1=1e-3; <span class="comment">%ogden c1</span>
        m1=6; <span class="comment">%ogden m1</span>
        k_factor=1; <span class="comment">%Bulk like modulus factor</span>
        k=c1*k_factor; <span class="comment">%The bulk like modulus</span>

        d=1e-9; <span class="comment">%Density</span>

        <span class="comment">%Constant Isotropic Permeability parameters</span>
        phi0=0.5; <span class="comment">%Solid volume fraction in reference configuration</span>
        permHydro=7.41e1; <span class="comment">%hydraulic permeability</span>
<span class="keyword">end</span>
<span class="comment">% FEA control settings</span>
analysisType=<span class="string">'static'</span>;
febioModule=<span class="string">'biphasic'</span>;

t_load=0.1; <span class="comment">%Time from start to max load</span>
t_step_ini1=t_load/50; <span class="comment">%Initial desired step size</span>
numTimeSteps1=round(t_load/t_step_ini1); <span class="comment">%Number of time steps desired</span>
t_step1=t_load/numTimeSteps1; <span class="comment">%Step size</span>
dtmin1=t_step1/100; <span class="comment">%Smallest allowed step size</span>
dtmax1=t_step1; <span class="comment">%Largest allowed step size</span>

t_hold=5;
t_step_ini2=t_step_ini1; <span class="comment">%Initial desired step size</span>
numTimeSteps2=round(t_hold/t_step_ini2); <span class="comment">%Number of time steps desired</span>
t_step2=t_hold/numTimeSteps2; <span class="comment">%Step size</span>
dtmin2=t_step2/100; <span class="comment">%Smallest allowed step size</span>
dtmax2=0.25; <span class="comment">%Largest allowed step size</span>

max_refs=25; <span class="comment">%Max reforms</span>
max_ups=0; <span class="comment">%Set to zero to use full-Newton iterations</span>
opt_iter=6; <span class="comment">%Optimum number of iterations</span>
max_retries=5; <span class="comment">%Maximum number of retires</span>
</pre><h2 id="5">Creating model geometry and mesh</h2><p>A box is created with tri-linear hexahedral (hex8) elements using the <tt>hexMeshBox</tt> function. The function offers the boundary faces with seperate labels for the top, bottom, left, right, front, and back sides. As such these can be used to define boundary conditions on the exterior.</p><pre class="codeinput"><span class="comment">% Create a box with hexahedral elements</span>
cubeDimensions=[sampleWidth sampleThickness sampleHeight]; <span class="comment">%Dimensions</span>
cubeElementNumbers=[numElementsWidth numElementsThickness numElementsHeight]; <span class="comment">%Number of elements</span>

<span class="keyword">switch</span> meshType
    <span class="keyword">case</span> <span class="string">'hex8'</span> <span class="comment">%hex8 structured</span>
        [meshStruct]=hexMeshBox(cubeDimensions,cubeElementNumbers,2);
    <span class="keyword">case</span> <span class="string">'tet4'</span> <span class="comment">%tet4 unstructured</span>
        [meshStruct]=tetMeshBox(cubeDimensions,mean(pointSpacings));
<span class="keyword">end</span>

<span class="comment">%Access elements, nodes, and faces from the structure</span>
E=meshStruct.elements; <span class="comment">%The elements</span>
V=meshStruct.nodes; <span class="comment">%The nodes (vertices)</span>
Fb=meshStruct.facesBoundary; <span class="comment">%The boundary faces</span>
Cb=meshStruct.boundaryMarker; <span class="comment">%The "colors" or labels for the boundary faces</span>
elementMaterialIndices=ones(size(E,1),1); <span class="comment">%Element material indices</span>
</pre><p>Plotting model boundary surfaces and a cut view</p><pre class="codeinput">hFig=cFigure;

subplot(1,2,1); hold <span class="string">on</span>;
title(<span class="string">'Model boundary surfaces and labels'</span>,<span class="string">'FontSize'</span>,fontSize);
gpatch(Fb,V,Cb,<span class="string">'k'</span>,faceAlpha1);
colormap(gjet(6)); icolorbar;
axisGeom(gca,fontSize);

hs=subplot(1,2,2); hold <span class="string">on</span>;
title(<span class="string">'Cut view of solid mesh'</span>,<span class="string">'FontSize'</span>,fontSize);
optionStruct.hFig=[hFig hs];
meshView(meshStruct,optionStruct);
axisGeom(gca,fontSize);

drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0018_cube_poroelastic_ramp_hold_01.jpg" alt=""> <h2 id="7">Defining the boundary conditions</h2><p>The visualization of the model boundary shows colors for each side of the cube. These labels can be used to define boundary conditions.</p><pre class="codeinput"><span class="comment">%Define supported node sets</span>
logicFace=Cb==1; <span class="comment">%Logic for current face set</span>
Fr=Fb(logicFace,:); <span class="comment">%The current face set</span>
bcSupportList_X=unique(Fr(:)); <span class="comment">%Node set part of selected face</span>

logicFace=Cb==3; <span class="comment">%Logic for current face set</span>
Fr=Fb(logicFace,:); <span class="comment">%The current face set</span>
bcSupportList_Y=unique(Fr(:)); <span class="comment">%Node set part of selected face</span>

logicFace=Cb==5; <span class="comment">%Logic for current face set</span>
Fr=Fb(logicFace,:); <span class="comment">%The current face set</span>
bcSupportList_Z=unique(Fr(:)); <span class="comment">%Node set part of selected face</span>

<span class="comment">%Prescribed displacement nodes</span>
logicPrescribe=Cb==6; <span class="comment">%Logic for current face set</span>
Fr=Fb(logicPrescribe,:); <span class="comment">%The current face set</span>
bcPrescribeList=unique(Fr(:)); <span class="comment">%Node set part of selected face</span>
</pre><p>Visualizing boundary conditions. Markers plotted on the semi-transparent model denote the nodes in the various boundary condition lists.</p><pre class="codeinput">hf=cFigure;
title(<span class="string">'Boundary conditions'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize);
hold <span class="string">on</span>;

gpatch(Fb,V,<span class="string">'kw'</span>,<span class="string">'k'</span>,0.5);

hl(1)=plotV(V(bcSupportList_X,:),<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
hl(2)=plotV(V(bcSupportList_Y,:),<span class="string">'g.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
hl(3)=plotV(V(bcSupportList_Z,:),<span class="string">'b.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
hl(4)=plotV(V(bcPrescribeList,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize);

legend(hl,{<span class="string">'BC x support'</span>,<span class="string">'BC y support'</span>,<span class="string">'BC z support'</span>,<span class="string">'BC z prescribe'</span>});

axisGeom(gca,fontSize);
camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0018_cube_poroelastic_ramp_hold_02.jpg" alt=""> <h2 id="9">Defining the FEBio input structure</h2><p>See also <tt>febioStructTemplate</tt> and <tt>febioStruct2xml</tt> and the FEBio user manual.</p><pre class="codeinput"><span class="comment">%Get a template with default settings</span>
[febio_spec]=febioStructTemplate;

<span class="comment">%febio_spec version</span>
febio_spec.ATTR.version=<span class="string">'2.5'</span>;

<span class="comment">%Module section</span>
febio_spec.Module.ATTR.type=febioModule;

<span class="comment">%Get control section from template</span>
stepStruct.Control=febio_spec.Control;
stepStruct.Control.symmetric_stiffness=0; <span class="comment">%Recommended for biphasic analysis</span>

<span class="comment">%Remove control field (part of template) since step specific control sections are used</span>
febio_spec=rmfield(febio_spec,<span class="string">'Control'</span>);

<span class="comment">%Control sections for each step</span>
febio_spec.Step{1}.ATTR.id=1;
febio_spec.Step{1}.Control=stepStruct.Control;
febio_spec.Step{1}.Control.analysis.ATTR.type=analysisType;
febio_spec.Step{1}.Control.time_steps=numTimeSteps1;
febio_spec.Step{1}.Control.step_size=t_step1;
febio_spec.Step{1}.Control.time_stepper.dtmin=dtmin1;
febio_spec.Step{1}.Control.time_stepper.dtmax=dtmax1;
febio_spec.Step{1}.Control.time_stepper.max_retries=max_retries;
febio_spec.Step{1}.Control.time_stepper.opt_iter=opt_iter;
febio_spec.Step{1}.Control.max_refs=max_refs;
febio_spec.Step{1}.Control.max_ups=max_ups;
febio_spec.Step{1}.Control.min_residual=min_residual;

febio_spec.Step{2}.ATTR.id=2;
febio_spec.Step{2}.Control=stepStruct.Control;
febio_spec.Step{2}.Control.analysis.ATTR.type=analysisType;
febio_spec.Step{2}.Control.time_steps=numTimeSteps2;
febio_spec.Step{2}.Control.step_size=t_step2;
febio_spec.Step{2}.Control.time_stepper.dtmin=dtmin2;
febio_spec.Step{2}.Control.time_stepper.dtmax=dtmax2;
febio_spec.Step{2}.Control.time_stepper.max_retries=max_retries;
febio_spec.Step{2}.Control.time_stepper.opt_iter=opt_iter;
febio_spec.Step{2}.Control.max_refs=max_refs;
febio_spec.Step{2}.Control.max_ups=max_ups;
febio_spec.Step{2}.Control.min_residual=min_residual;

<span class="comment">%Material section</span>

<span class="comment">%Viscous part</span>
febio_spec.Material.material{1}.ATTR.type=<span class="string">'biphasic'</span>;
febio_spec.Material.material{1}.ATTR.name=<span class="string">'Block_material'</span>;
febio_spec.Material.material{1}.ATTR.id=1;
febio_spec.Material.material{1}.phi0=phi0;
febio_spec.Material.material{1}.permeability.ATTR.type=<span class="string">'perm-const-iso'</span>;
febio_spec.Material.material{1}.permeability.ATTR.name=<span class="string">'permeability'</span>;
febio_spec.Material.material{1}.permeability.perm=permHydro;
febio_spec.Material.material{1}.fluid_density=d;

<span class="comment">%Solid part</span>
febio_spec.Material.material{1}.solid{1}.ATTR.type=<span class="string">'Ogden unconstrained'</span>;
febio_spec.Material.material{1}.solid{1}.c1=c1;
febio_spec.Material.material{1}.solid{1}.m1=m1;
<span class="comment">% febio_spec.Material.material{1}.solid{1}.c2=c1;</span>
<span class="comment">% febio_spec.Material.material{1}.solid{1}.m2=-m1;</span>
febio_spec.Material.material{1}.solid{1}.cp=k;
febio_spec.Material.material{1}.solid{1}.density=d;

<span class="comment">%Geometry section</span>
<span class="comment">% -&gt; Nodes</span>
febio_spec.Geometry.Nodes{1}.ATTR.name=<span class="string">'nodeSet_all'</span>; <span class="comment">%The node set name</span>
febio_spec.Geometry.Nodes{1}.node.ATTR.id=(1:size(V,1))'; <span class="comment">%The node id's</span>
febio_spec.Geometry.Nodes{1}.node.VAL=V; <span class="comment">%The nodel coordinates</span>

<span class="comment">% -&gt; Elements</span>
febio_spec.Geometry.Elements{1}.ATTR.type=meshType; <span class="comment">%Element type of this set</span>
febio_spec.Geometry.Elements{1}.ATTR.mat=1; <span class="comment">%material index for this set</span>
febio_spec.Geometry.Elements{1}.ATTR.name=<span class="string">'Cube'</span>; <span class="comment">%Name of the element set</span>
febio_spec.Geometry.Elements{1}.elem.ATTR.id=(1:1:size(E,1))'; <span class="comment">%Element id's</span>
febio_spec.Geometry.Elements{1}.elem.VAL=E;

<span class="comment">% -&gt; NodeSets</span>
febio_spec.Geometry.NodeSet{1}.ATTR.name=<span class="string">'bcSupportList_X'</span>;
febio_spec.Geometry.NodeSet{1}.node.ATTR.id=bcSupportList_X(:);

febio_spec.Geometry.NodeSet{2}.ATTR.name=<span class="string">'bcSupportList_Y'</span>;
febio_spec.Geometry.NodeSet{2}.node.ATTR.id=bcSupportList_Y(:);

febio_spec.Geometry.NodeSet{3}.ATTR.name=<span class="string">'bcSupportList_Z'</span>;
febio_spec.Geometry.NodeSet{3}.node.ATTR.id=bcSupportList_Z(:);

febio_spec.Geometry.NodeSet{4}.ATTR.name=<span class="string">'bcPrescribeList'</span>;
febio_spec.Geometry.NodeSet{4}.node.ATTR.id=bcPrescribeList(:);

<span class="comment">%Boundary condition section</span>
<span class="comment">% -&gt; Fix boundary conditions</span>
febio_spec.Boundary.fix{1}.ATTR.bc=<span class="string">'x'</span>;
febio_spec.Boundary.fix{1}.ATTR.node_set=febio_spec.Geometry.NodeSet{1}.ATTR.name;
febio_spec.Boundary.fix{2}.ATTR.bc=<span class="string">'y'</span>;
febio_spec.Boundary.fix{2}.ATTR.node_set=febio_spec.Geometry.NodeSet{2}.ATTR.name;
febio_spec.Boundary.fix{3}.ATTR.bc=<span class="string">'z'</span>;
febio_spec.Boundary.fix{3}.ATTR.node_set=febio_spec.Geometry.NodeSet{3}.ATTR.name;

<span class="comment">% -&gt; Prescribe boundary conditions</span>
febio_spec.Boundary.prescribe{1}.ATTR.bc=<span class="string">'z'</span>;
febio_spec.Boundary.prescribe{1}.ATTR.node_set=febio_spec.Geometry.NodeSet{4}.ATTR.name;
febio_spec.Boundary.prescribe{1}.scale.ATTR.lc=1;
febio_spec.Boundary.prescribe{1}.scale.VAL=1;
febio_spec.Boundary.prescribe{1}.relative=1;
febio_spec.Boundary.prescribe{1}.value=displacementMagnitude;

febio_spec.Boundary.prescribe{2}.ATTR.node_set=febio_spec.Geometry.NodeSet{4}.ATTR.name;
febio_spec.Boundary.prescribe{2}.ATTR.bc=<span class="string">'p'</span>;
febio_spec.Boundary.prescribe{2}.scale.ATTR.lc=1;
febio_spec.Boundary.prescribe{2}.scale.VAL=0;

<span class="comment">%LoadData section</span>
<span class="comment">% -&gt; Load curves</span>
febio_spec.LoadData.loadcurve{1}.ATTR.id=1;
febio_spec.LoadData.loadcurve{1}.ATTR.type=<span class="string">'linear'</span>;
febio_spec.LoadData.loadcurve{1}.point.VAL=[0 0;t_load 1;(t_load+t_hold) 1];

<span class="comment">%Output section</span>
<span class="comment">% -&gt; log file</span>
febio_spec.Output.logfile.ATTR.file=febioLogFileName;
febio_spec.Output.logfile.node_data{1}.ATTR.file=febioLogFileName_disp;
febio_spec.Output.logfile.node_data{1}.ATTR.data=<span class="string">'ux;uy;uz'</span>;
febio_spec.Output.logfile.node_data{1}.ATTR.delim=<span class="string">','</span>;
febio_spec.Output.logfile.node_data{1}.VAL=1:size(V,1);

febio_spec.Output.logfile.node_data{2}.ATTR.file=febioLogFileName_force;
febio_spec.Output.logfile.node_data{2}.ATTR.data=<span class="string">'Rx;Ry;Rz'</span>;
febio_spec.Output.logfile.node_data{2}.ATTR.delim=<span class="string">','</span>;
febio_spec.Output.logfile.node_data{2}.VAL=1:size(V,1);

febio_spec.Output.logfile.element_data{1}.ATTR.file=febioLogFileName_stress;
febio_spec.Output.logfile.element_data{1}.ATTR.data=<span class="string">'sz'</span>;
febio_spec.Output.logfile.element_data{1}.ATTR.delim=<span class="string">','</span>;
febio_spec.Output.logfile.element_data{1}.VAL=1:size(E,1);
</pre><h2 id="10">Quick viewing of the FEBio input file structure</h2><p>The <tt>febView</tt> function can be used to view the xml structure in a MATLAB figure window. febView(febio_spec)</p><p><tt>febView(febio_spec); %Viewing the febio file</tt></p><h2 id="12">Exporting the FEBio input file</h2><p>Exporting the febio_spec structure to an FEBio input file is done using the <tt>febioStruct2xml</tt> function.</p><pre class="codeinput">febioStruct2xml(febio_spec,febioFebFileName); <span class="comment">%Exporting to file and domNode</span>
</pre><h2 id="13">Running the FEBio analysis</h2><p>To run the analysis defined by the created FEBio input file the <tt>runMonitorFEBio</tt> function is used. The input for this function is a structure defining job settings e.g. the FEBio input file name. The optional output runFlag informs the user if the analysis was run succesfully.</p><pre class="codeinput">febioAnalysis.run_filename=febioFebFileName; <span class="comment">%The input file name</span>
febioAnalysis.run_logname=febioLogFileName; <span class="comment">%The name for the log file</span>
febioAnalysis.disp_on=1; <span class="comment">%Display information on the command window</span>
febioAnalysis.disp_log_on=1; <span class="comment">%Display convergence information in the command window</span>
febioAnalysis.runMode=<span class="string">'external'</span>;<span class="comment">%'internal';</span>
febioAnalysis.t_check=0.25; <span class="comment">%Time for checking log file (dont set too small)</span>
febioAnalysis.maxtpi=1e99; <span class="comment">%Max analysis time</span>
febioAnalysis.maxLogCheckTime=3; <span class="comment">%Max log file checking time</span>

[runFlag]=runMonitorFEBio(febioAnalysis);<span class="comment">%START FEBio NOW!!!!!!!!</span>
</pre><pre class="codeoutput"> 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- STARTING FEBIO JOB --- 04-Jun-2019 12:49:01
Waiting for log file...
Proceeding to check log file...04-Jun-2019 12:49:03
------- converged at time : 0.002
------- converged at time : 0.004
------- converged at time : 0.006
------- converged at time : 0.008
------- converged at time : 0.01
------- converged at time : 0.012
------- converged at time : 0.014
------- converged at time : 0.016
------- converged at time : 0.018
------- converged at time : 0.02
------- converged at time : 0.022
------- converged at time : 0.024
------- converged at time : 0.026
------- converged at time : 0.028
------- converged at time : 0.03
------- converged at time : 0.032
------- converged at time : 0.034
------- converged at time : 0.036
------- converged at time : 0.038
------- converged at time : 0.04
------- converged at time : 0.042
------- converged at time : 0.044
------- converged at time : 0.046
------- converged at time : 0.048
------- converged at time : 0.05
------- converged at time : 0.052
------- converged at time : 0.054
------- converged at time : 0.056
------- converged at time : 0.058
------- converged at time : 0.06
------- converged at time : 0.062
------- converged at time : 0.064
------- converged at time : 0.066
------- converged at time : 0.068
------- converged at time : 0.07
------- converged at time : 0.072
------- converged at time : 0.074
------- converged at time : 0.076
------- converged at time : 0.078
------- converged at time : 0.08
------- converged at time : 0.082
------- converged at time : 0.084
------- converged at time : 0.086
------- converged at time : 0.088
------- converged at time : 0.09
------- converged at time : 0.092
------- converged at time : 0.094
------- converged at time : 0.096
------- converged at time : 0.098
------- converged at time : 0.1
------- converged at time : 0.102
------- converged at time : 0.112
------- converged at time : 0.162
------- converged at time : 0.252
------- converged at time : 0.374
------- converged at time : 0.5216
------- converged at time : 0.68968
------- converged at time : 0.874144
------- converged at time : 1.07172
------- converged at time : 1.27977
------- converged at time : 1.49622
------- converged at time : 1.71937
------- converged at time : 1.9479
------- converged at time : 2.18072
------- converged at time : 2.41698
------- converged at time : 2.65598
------- converged at time : 2.89718
------- converged at time : 3.14015
------- converged at time : 3.38452
------- converged at time : 3.63001
------- converged at time : 3.87641
------- converged at time : 4.12353
------- converged at time : 4.37122
------- converged at time : 4.61938
------- converged at time : 4.8679
------- converged at time : 5.1
--- Done --- 04-Jun-2019 12:49:06
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0018_cube_poroelastic_ramp_hold_03.jpg" alt=""> <img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0018_cube_poroelastic_ramp_hold_04.jpg" alt=""> <h2 id="14">Import FEBio results</h2><pre class="codeinput"><span class="keyword">if</span> runFlag==1 <span class="comment">%i.e. a succesful run</span>
</pre><pre class="codeinput">    <span class="comment">% Importing nodal displacements from a log file</span>
    [~, N_disp_mat,~]=importFEBio_logfile(fullfile(savePath,febioLogFileName_disp)); <span class="comment">%Nodal displacements</span>

    N_disp_mat=N_disp_mat(:,2:end,:);
    sizImport=size(N_disp_mat);
    sizImport(3)=sizImport(3)+1;
    N_disp_mat_n=zeros(sizImport);
    N_disp_mat_n(:,:,2:end)=N_disp_mat;
    N_disp_mat=N_disp_mat_n;
    DN=N_disp_mat(:,:,end);
    DN_magnitude=sqrt(sum(DN(:,3).^2,2));
    V_def=V+DN;
    [CF]=vertexToFaceMeasure(Fb,DN_magnitude);

    <span class="comment">% Importing element stress from a log file</span>
    [time_mat, E_stress_mat,~]=importFEBio_logfile(fullfile(savePath,febioLogFileName_stress)); <span class="comment">%Nodal forces</span>
    time_mat=[0; time_mat(:)]; <span class="comment">%Time</span>
    stress_cauchy_sim=[0; mean(squeeze(E_stress_mat(:,end,:)),1)'];
</pre><p>Plotting the simulated results using <tt>anim8</tt> to visualize and animate deformations</p><pre class="codeinput">    <span class="comment">% Create basic view and store graphics handle to initiate animation</span>
    hf=cFigure; <span class="comment">%Open figure</span>
    gtitle([febioFebFileNamePart,<span class="string">': Press play to animate'</span>]);
    hp=gpatch(Fb,V_def,CF,<span class="string">'k'</span>,1); <span class="comment">%Add graphics object to animate</span>
    gpatch(Fb,V,0.5*ones(1,3),<span class="string">'k'</span>,0.25); <span class="comment">%A static graphics object</span>

    axisGeom(gca,fontSize);
    colormap(gjet(250)); colorbar;
    caxis([0 max(DN_magnitude)]);
    axis([min(V_def(:,1)) max(V_def(:,1)) min(V_def(:,2)) max(V_def(:,2)) min(V_def(:,3)) max(V_def(:,3))]); <span class="comment">%Set axis limits statically</span>
    view(130,25); <span class="comment">%Set view direction</span>
    camlight <span class="string">headlight</span>;

    <span class="comment">% Set up animation features</span>
    animStruct.Time=time_mat; <span class="comment">%The time vector</span>
    <span class="keyword">for</span> qt=1:1:size(N_disp_mat,3) <span class="comment">%Loop over time increments</span>
        DN=N_disp_mat(:,:,qt); <span class="comment">%Current displacement</span>
        DN_magnitude=sqrt(sum(DN.^2,2)); <span class="comment">%Current displacement magnitude</span>
        V_def=V+DN; <span class="comment">%Current nodal coordinates</span>
        [CF]=vertexToFaceMeasure(Fb,DN_magnitude); <span class="comment">%Current color data to use</span>

        <span class="comment">%Set entries in animation structure</span>
        animStruct.Handles{qt}=[hp hp]; <span class="comment">%Handles of objects to animate</span>
        animStruct.Props{qt}={<span class="string">'Vertices'</span>,<span class="string">'CData'</span>}; <span class="comment">%Properties of objects to animate</span>
        animStruct.Set{qt}={V_def,CF}; <span class="comment">%Property values for to set in order to animate</span>
    <span class="keyword">end</span>
    anim8(hf,animStruct); <span class="comment">%Initiate animation feature</span>
    drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0018_cube_poroelastic_ramp_hold_05.jpg" alt=""> <p>Calculate the simulated applied uniaxial stretch</p><pre class="codeinput">    DZ_set=N_disp_mat(bcPrescribeList,end,:); <span class="comment">%Z displacements of the prescribed set</span>
    DZ_set=mean(DZ_set,1); <span class="comment">%Calculate mean Z displacements across nodes</span>
    stretch_sim=(DZ_set(:)+sampleHeight)./sampleHeight; <span class="comment">%Derive stretch</span>
</pre><p>Visualize stress-stretch curve</p><pre class="codeinput">    cFigure;
    hold <span class="string">on</span>;
    title(<span class="string">'Cauchy stress-time curve'</span>,<span class="string">'FontSize'</span>,fontSize);
    xlabel(<span class="string">'Time [s]'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'\sigma Cauchy stress [Pa]'</span>,<span class="string">'FontSize'</span>,fontSize);

    plot(time_mat(:),stress_cauchy_sim(:),<span class="string">'r-'</span>,<span class="string">'lineWidth'</span>,lineWidth);

    view(2); axis <span class="string">tight</span>;  grid <span class="string">on</span>; axis <span class="string">square</span>; box <span class="string">on</span>;
    set(gca,<span class="string">'FontSize'</span>,fontSize);
    drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0018_cube_poroelastic_ramp_hold_06.jpg" alt=""> <pre class="codeinput"><span class="keyword">end</span>
</pre><p><img vspace="5" hspace="5" src="gibbVerySmall.gif" alt=""> </p><p><i><b>GIBBON</b></i> <a href="www.gibboncode.org">www.gibboncode.org</a></p><p><i>Kevin Mattheus Moerman</i>, <a href="gibbon.toolbox@gmail.com">gibbon.toolbox@gmail.com</a></p><p><i><b>GIBBON footer text</b></i></p><p>License: <a href="https://github.com/gibbonCode/GIBBON/blob/master/LICENSE">https://github.com/gibbonCode/GIBBON/blob/master/LICENSE</a></p><p>GIBBON: The Geometry and Image-based Bioengineering add-On. A toolbox for image segmentation, image-based modeling, meshing, and finite element analysis.</p><p>Copyright (C) 2019  Kevin Mattheus Moerman</p><p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p><p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p><p>You should have received a copy of the GNU General Public License along with this program.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% DEMO_febio_0018_cube_poroelastic_ramp_hold
% Below is a demonstration for:
% 
% * Building geometry for a cube with hexahedral elements
% * Defining the boundary conditions 
% * Coding the febio structure
% * Running the model
% * Importing and visualizing the displacement and stress results

%% Keywords
%
% * febio_spec version 2.5
% * febio, FEBio
% * uniaxial loading
% * compression, tension, compressive, tensile
% * displacement control, displacement boundary condition
% * hexahedral elements, hex8
% * cube, box, rectangular
% * static, solid
% * hyperelastic, Ogden
% * viscoelastic
% * poroelastic
% * biphasic
% * uncoupled, coupled
% * ramp hold
% * displacement logfile
% * stress logfile

%%

clear; close all; clc;

%% Plot settings
fontSize=20;
faceAlpha1=0.8;
markerSize=40;
lineWidth=3;

%% Control parameters

% Path names
defaultFolder = fileparts(fileparts(mfilename('fullpath')));
savePath=fullfile(defaultFolder,'data','temp');

% Defining file names
febioFebFileNamePart='tempModel';
febioFebFileName=fullfile(savePath,[febioFebFileNamePart,'.feb']); %FEB file name
febioLogFileName=fullfile(savePath,[febioFebFileNamePart,'.txt']); %FEBio log file name
febioLogFileName_disp=[febioFebFileNamePart,'_disp_out.txt']; %Log file name for exporting displacement
febioLogFileName_force=[febioFebFileNamePart,'_force_out.txt']; %Log file name for exporting force
febioLogFileName_stress=[febioFebFileNamePart,'_stress_out.txt']; %Log file name for exporting stress

%Specifying dimensions and number of elements
meshType='hex8'; %hex8 or tet4
unitSystem=2; %1=m, 2=mm
switch unitSystem
    case 1
        min_residual=1e-40;
        cubeSize=10e-3;
        sampleWidth=cubeSize; %Width
        sampleThickness=cubeSize; %Thickness
        sampleHeight=cubeSize; %Height
        pointSpacings=2e-3*ones(1,3); %Desired point spacing between nodes
        numElementsWidth=round(sampleWidth/pointSpacings(1)); %Number of elemens in dir 1
        numElementsThickness=round(sampleThickness/pointSpacings(2)); %Number of elemens in dir 2
        numElementsHeight=round(sampleHeight/pointSpacings(3)); %Number of elemens in dir 3
        
        %Define applied displacement
        appliedStrain=0.3; %Linear strain (Only used to compute applied stretch)
        loadingOption='compression'; % or 'tension'
        switch loadingOption
            case 'compression'
                stretchLoad=1-appliedStrain; %The applied stretch for uniaxial loading
            case 'tension'
                stretchLoad=1+appliedStrain; %The applied stretch for uniaxial loading
        end
        displacementMagnitude=(stretchLoad*sampleHeight)-sampleHeight; %The displacement magnitude
        
        %Material parameter set
        
        %Hyperelastic parameters
        c1=1000; %ogden c1
        m1=6; %ogden m1
        k_factor=1; %Bulk like modulus factor
        k=c1*k_factor; %The bulk like modulus
        
        d=1000; %Density
        
        %Constant Isotropic Permeability parameters
        phi0=0.5; %Solid volume fraction in reference configuration
        permHydro=7.41e-11; %hydraulic permeability
    case 2
        min_residual=1e-40;
        cubeSize=10;
        sampleWidth=cubeSize; %Width
        sampleThickness=cubeSize; %Thickness
        sampleHeight=cubeSize; %Height
        pointSpacings=2*ones(1,3); %Desired point spacing between nodes
        numElementsWidth=round(sampleWidth/pointSpacings(1)); %Number of elemens in dir 1
        numElementsThickness=round(sampleThickness/pointSpacings(2)); %Number of elemens in dir 2
        numElementsHeight=round(sampleHeight/pointSpacings(3)); %Number of elemens in dir 3
        
        %Define applied displacement
        appliedStrain=0.3; %Linear strain (Only used to compute applied stretch)
        loadingOption='compression'; % or 'tension'
        switch loadingOption
            case 'compression'
                stretchLoad=1-appliedStrain; %The applied stretch for uniaxial loading
            case 'tension'
                stretchLoad=1+appliedStrain; %The applied stretch for uniaxial loading
        end
        displacementMagnitude=(stretchLoad*sampleHeight)-sampleHeight; %The displacement magnitude
        
        %Material parameter set
        
        %Hyperelastic parameters
        c1=1e-3; %ogden c1
        m1=6; %ogden m1
        k_factor=1; %Bulk like modulus factor
        k=c1*k_factor; %The bulk like modulus
        
        d=1e-9; %Density
        
        %Constant Isotropic Permeability parameters
        phi0=0.5; %Solid volume fraction in reference configuration
        permHydro=7.41e1; %hydraulic permeability
end
% FEA control settings
analysisType='static'; 
febioModule='biphasic';

t_load=0.1; %Time from start to max load
t_step_ini1=t_load/50; %Initial desired step size
numTimeSteps1=round(t_load/t_step_ini1); %Number of time steps desired
t_step1=t_load/numTimeSteps1; %Step size
dtmin1=t_step1/100; %Smallest allowed step size
dtmax1=t_step1; %Largest allowed step size

t_hold=5;
t_step_ini2=t_step_ini1; %Initial desired step size
numTimeSteps2=round(t_hold/t_step_ini2); %Number of time steps desired
t_step2=t_hold/numTimeSteps2; %Step size
dtmin2=t_step2/100; %Smallest allowed step size
dtmax2=0.25; %Largest allowed step size

max_refs=25; %Max reforms
max_ups=0; %Set to zero to use full-Newton iterations
opt_iter=6; %Optimum number of iterations
max_retries=5; %Maximum number of retires

%% Creating model geometry and mesh
% A box is created with tri-linear hexahedral (hex8) elements using the
% |hexMeshBox| function. The function offers the boundary faces with
% seperate labels for the top, bottom, left, right, front, and back sides.
% As such these can be used to define boundary conditions on the exterior. 

% Create a box with hexahedral elements
cubeDimensions=[sampleWidth sampleThickness sampleHeight]; %Dimensions
cubeElementNumbers=[numElementsWidth numElementsThickness numElementsHeight]; %Number of elements

switch meshType
    case 'hex8' %hex8 structured
        [meshStruct]=hexMeshBox(cubeDimensions,cubeElementNumbers,2);
    case 'tet4' %tet4 unstructured
        [meshStruct]=tetMeshBox(cubeDimensions,mean(pointSpacings));
end

%Access elements, nodes, and faces from the structure
E=meshStruct.elements; %The elements 
V=meshStruct.nodes; %The nodes (vertices)
Fb=meshStruct.facesBoundary; %The boundary faces
Cb=meshStruct.boundaryMarker; %The "colors" or labels for the boundary faces
elementMaterialIndices=ones(size(E,1),1); %Element material indices

%% 
% Plotting model boundary surfaces and a cut view

hFig=cFigure; 

subplot(1,2,1); hold on; 
title('Model boundary surfaces and labels','FontSize',fontSize);
gpatch(Fb,V,Cb,'k',faceAlpha1); 
colormap(gjet(6)); icolorbar;
axisGeom(gca,fontSize);

hs=subplot(1,2,2); hold on; 
title('Cut view of solid mesh','FontSize',fontSize);
optionStruct.hFig=[hFig hs];
meshView(meshStruct,optionStruct);
axisGeom(gca,fontSize);

drawnow;

%% Defining the boundary conditions
% The visualization of the model boundary shows colors for each side of the
% cube. These labels can be used to define boundary conditions. 

%Define supported node sets
logicFace=Cb==1; %Logic for current face set
Fr=Fb(logicFace,:); %The current face set
bcSupportList_X=unique(Fr(:)); %Node set part of selected face

logicFace=Cb==3; %Logic for current face set
Fr=Fb(logicFace,:); %The current face set
bcSupportList_Y=unique(Fr(:)); %Node set part of selected face

logicFace=Cb==5; %Logic for current face set
Fr=Fb(logicFace,:); %The current face set
bcSupportList_Z=unique(Fr(:)); %Node set part of selected face

%Prescribed displacement nodes
logicPrescribe=Cb==6; %Logic for current face set
Fr=Fb(logicPrescribe,:); %The current face set
bcPrescribeList=unique(Fr(:)); %Node set part of selected face

%% 
% Visualizing boundary conditions. Markers plotted on the semi-transparent
% model denote the nodes in the various boundary condition lists. 

hf=cFigure;
title('Boundary conditions','FontSize',fontSize);
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize);
hold on;

gpatch(Fb,V,'kw','k',0.5);

hl(1)=plotV(V(bcSupportList_X,:),'r.','MarkerSize',markerSize);
hl(2)=plotV(V(bcSupportList_Y,:),'g.','MarkerSize',markerSize);
hl(3)=plotV(V(bcSupportList_Z,:),'b.','MarkerSize',markerSize);
hl(4)=plotV(V(bcPrescribeList,:),'k.','MarkerSize',markerSize);

legend(hl,{'BC x support','BC y support','BC z support','BC z prescribe'});

axisGeom(gca,fontSize);
camlight headlight; 
drawnow; 

%% Defining the FEBio input structure
% See also |febioStructTemplate| and |febioStruct2xml| and the FEBio user
% manual.

%Get a template with default settings 
[febio_spec]=febioStructTemplate;

%febio_spec version 
febio_spec.ATTR.version='2.5'; 

%Module section
febio_spec.Module.ATTR.type=febioModule; 

%Get control section from template
stepStruct.Control=febio_spec.Control;
stepStruct.Control.symmetric_stiffness=0; %Recommended for biphasic analysis

%Remove control field (part of template) since step specific control sections are used
febio_spec=rmfield(febio_spec,'Control'); 

%Control sections for each step
febio_spec.Step{1}.ATTR.id=1;
febio_spec.Step{1}.Control=stepStruct.Control;
febio_spec.Step{1}.Control.analysis.ATTR.type=analysisType;
febio_spec.Step{1}.Control.time_steps=numTimeSteps1;
febio_spec.Step{1}.Control.step_size=t_step1;
febio_spec.Step{1}.Control.time_stepper.dtmin=dtmin1;
febio_spec.Step{1}.Control.time_stepper.dtmax=dtmax1; 
febio_spec.Step{1}.Control.time_stepper.max_retries=max_retries;
febio_spec.Step{1}.Control.time_stepper.opt_iter=opt_iter;
febio_spec.Step{1}.Control.max_refs=max_refs;
febio_spec.Step{1}.Control.max_ups=max_ups;
febio_spec.Step{1}.Control.min_residual=min_residual;

febio_spec.Step{2}.ATTR.id=2;
febio_spec.Step{2}.Control=stepStruct.Control;
febio_spec.Step{2}.Control.analysis.ATTR.type=analysisType;
febio_spec.Step{2}.Control.time_steps=numTimeSteps2;
febio_spec.Step{2}.Control.step_size=t_step2;
febio_spec.Step{2}.Control.time_stepper.dtmin=dtmin2;
febio_spec.Step{2}.Control.time_stepper.dtmax=dtmax2; 
febio_spec.Step{2}.Control.time_stepper.max_retries=max_retries;
febio_spec.Step{2}.Control.time_stepper.opt_iter=opt_iter;
febio_spec.Step{2}.Control.max_refs=max_refs;
febio_spec.Step{2}.Control.max_ups=max_ups;
febio_spec.Step{2}.Control.min_residual=min_residual;

%Material section

%Viscous part
febio_spec.Material.material{1}.ATTR.type='biphasic';
febio_spec.Material.material{1}.ATTR.name='Block_material';
febio_spec.Material.material{1}.ATTR.id=1;
febio_spec.Material.material{1}.phi0=phi0;
febio_spec.Material.material{1}.permeability.ATTR.type='perm-const-iso';
febio_spec.Material.material{1}.permeability.ATTR.name='permeability';
febio_spec.Material.material{1}.permeability.perm=permHydro;
febio_spec.Material.material{1}.fluid_density=d;

%Solid part
febio_spec.Material.material{1}.solid{1}.ATTR.type='Ogden unconstrained';
febio_spec.Material.material{1}.solid{1}.c1=c1;
febio_spec.Material.material{1}.solid{1}.m1=m1;
% febio_spec.Material.material{1}.solid{1}.c2=c1;
% febio_spec.Material.material{1}.solid{1}.m2=-m1;
febio_spec.Material.material{1}.solid{1}.cp=k;
febio_spec.Material.material{1}.solid{1}.density=d;

%Geometry section
% -> Nodes
febio_spec.Geometry.Nodes{1}.ATTR.name='nodeSet_all'; %The node set name
febio_spec.Geometry.Nodes{1}.node.ATTR.id=(1:size(V,1))'; %The node id's
febio_spec.Geometry.Nodes{1}.node.VAL=V; %The nodel coordinates

% -> Elements
febio_spec.Geometry.Elements{1}.ATTR.type=meshType; %Element type of this set
febio_spec.Geometry.Elements{1}.ATTR.mat=1; %material index for this set 
febio_spec.Geometry.Elements{1}.ATTR.name='Cube'; %Name of the element set
febio_spec.Geometry.Elements{1}.elem.ATTR.id=(1:1:size(E,1))'; %Element id's
febio_spec.Geometry.Elements{1}.elem.VAL=E;

% -> NodeSets
febio_spec.Geometry.NodeSet{1}.ATTR.name='bcSupportList_X';
febio_spec.Geometry.NodeSet{1}.node.ATTR.id=bcSupportList_X(:);

febio_spec.Geometry.NodeSet{2}.ATTR.name='bcSupportList_Y';
febio_spec.Geometry.NodeSet{2}.node.ATTR.id=bcSupportList_Y(:);

febio_spec.Geometry.NodeSet{3}.ATTR.name='bcSupportList_Z';
febio_spec.Geometry.NodeSet{3}.node.ATTR.id=bcSupportList_Z(:);

febio_spec.Geometry.NodeSet{4}.ATTR.name='bcPrescribeList';
febio_spec.Geometry.NodeSet{4}.node.ATTR.id=bcPrescribeList(:);

%Boundary condition section 
% -> Fix boundary conditions
febio_spec.Boundary.fix{1}.ATTR.bc='x';
febio_spec.Boundary.fix{1}.ATTR.node_set=febio_spec.Geometry.NodeSet{1}.ATTR.name;
febio_spec.Boundary.fix{2}.ATTR.bc='y';
febio_spec.Boundary.fix{2}.ATTR.node_set=febio_spec.Geometry.NodeSet{2}.ATTR.name;
febio_spec.Boundary.fix{3}.ATTR.bc='z';
febio_spec.Boundary.fix{3}.ATTR.node_set=febio_spec.Geometry.NodeSet{3}.ATTR.name;

% -> Prescribe boundary conditions
febio_spec.Boundary.prescribe{1}.ATTR.bc='z';
febio_spec.Boundary.prescribe{1}.ATTR.node_set=febio_spec.Geometry.NodeSet{4}.ATTR.name;
febio_spec.Boundary.prescribe{1}.scale.ATTR.lc=1;
febio_spec.Boundary.prescribe{1}.scale.VAL=1;
febio_spec.Boundary.prescribe{1}.relative=1;
febio_spec.Boundary.prescribe{1}.value=displacementMagnitude;

febio_spec.Boundary.prescribe{2}.ATTR.node_set=febio_spec.Geometry.NodeSet{4}.ATTR.name;
febio_spec.Boundary.prescribe{2}.ATTR.bc='p';
febio_spec.Boundary.prescribe{2}.scale.ATTR.lc=1;
febio_spec.Boundary.prescribe{2}.scale.VAL=0;

%LoadData section 
% -> Load curves
febio_spec.LoadData.loadcurve{1}.ATTR.id=1;
febio_spec.LoadData.loadcurve{1}.ATTR.type='linear';
febio_spec.LoadData.loadcurve{1}.point.VAL=[0 0;t_load 1;(t_load+t_hold) 1];

%Output section 
% -> log file
febio_spec.Output.logfile.ATTR.file=febioLogFileName;
febio_spec.Output.logfile.node_data{1}.ATTR.file=febioLogFileName_disp;
febio_spec.Output.logfile.node_data{1}.ATTR.data='ux;uy;uz';
febio_spec.Output.logfile.node_data{1}.ATTR.delim=',';
febio_spec.Output.logfile.node_data{1}.VAL=1:size(V,1);

febio_spec.Output.logfile.node_data{2}.ATTR.file=febioLogFileName_force;
febio_spec.Output.logfile.node_data{2}.ATTR.data='Rx;Ry;Rz';
febio_spec.Output.logfile.node_data{2}.ATTR.delim=',';
febio_spec.Output.logfile.node_data{2}.VAL=1:size(V,1);

febio_spec.Output.logfile.element_data{1}.ATTR.file=febioLogFileName_stress;
febio_spec.Output.logfile.element_data{1}.ATTR.data='sz';
febio_spec.Output.logfile.element_data{1}.ATTR.delim=',';
febio_spec.Output.logfile.element_data{1}.VAL=1:size(E,1);

%% Quick viewing of the FEBio input file structure
% The |febView| function can be used to view the xml structure in a MATLAB
% figure window. 
% febView(febio_spec)

%%
% |febView(febio_spec); %Viewing the febio file|

%% Exporting the FEBio input file
% Exporting the febio_spec structure to an FEBio input file is done using
% the |febioStruct2xml| function. 

febioStruct2xml(febio_spec,febioFebFileName); %Exporting to file and domNode

%% Running the FEBio analysis
% To run the analysis defined by the created FEBio input file the
% |runMonitorFEBio| function is used. The input for this function is a
% structure defining job settings e.g. the FEBio input file name. The
% optional output runFlag informs the user if the analysis was run
% succesfully. 

febioAnalysis.run_filename=febioFebFileName; %The input file name
febioAnalysis.run_logname=febioLogFileName; %The name for the log file
febioAnalysis.disp_on=1; %Display information on the command window
febioAnalysis.disp_log_on=1; %Display convergence information in the command window
febioAnalysis.runMode='external';%'internal';
febioAnalysis.t_check=0.25; %Time for checking log file (dont set too small)
febioAnalysis.maxtpi=1e99; %Max analysis time
febioAnalysis.maxLogCheckTime=3; %Max log file checking time

[runFlag]=runMonitorFEBio(febioAnalysis);%START FEBio NOW!!!!!!!!

%% Import FEBio results 

if runFlag==1 %i.e. a succesful run
    
    % Importing nodal displacements from a log file
    [~, N_disp_mat,~]=importFEBio_logfile(fullfile(savePath,febioLogFileName_disp)); %Nodal displacements    
    
    N_disp_mat=N_disp_mat(:,2:end,:);
    sizImport=size(N_disp_mat);
    sizImport(3)=sizImport(3)+1;
    N_disp_mat_n=zeros(sizImport);
    N_disp_mat_n(:,:,2:end)=N_disp_mat;
    N_disp_mat=N_disp_mat_n;
    DN=N_disp_mat(:,:,end);
    DN_magnitude=sqrt(sum(DN(:,3).^2,2));
    V_def=V+DN;
    [CF]=vertexToFaceMeasure(Fb,DN_magnitude);
    
    % Importing element stress from a log file
    [time_mat, E_stress_mat,~]=importFEBio_logfile(fullfile(savePath,febioLogFileName_stress)); %Nodal forces
    time_mat=[0; time_mat(:)]; %Time
    stress_cauchy_sim=[0; mean(squeeze(E_stress_mat(:,end,:)),1)'];
    
    %% 
    % Plotting the simulated results using |anim8| to visualize and animate
    % deformations 
    
    % Create basic view and store graphics handle to initiate animation
    hf=cFigure; %Open figure  
    gtitle([febioFebFileNamePart,': Press play to animate']);
    hp=gpatch(Fb,V_def,CF,'k',1); %Add graphics object to animate
    gpatch(Fb,V,0.5*ones(1,3),'k',0.25); %A static graphics object
    
    axisGeom(gca,fontSize); 
    colormap(gjet(250)); colorbar;
    caxis([0 max(DN_magnitude)]);    
    axis([min(V_def(:,1)) max(V_def(:,1)) min(V_def(:,2)) max(V_def(:,2)) min(V_def(:,3)) max(V_def(:,3))]); %Set axis limits statically
    view(130,25); %Set view direction
    camlight headlight;        
        
    % Set up animation features
    animStruct.Time=time_mat; %The time vector    
    for qt=1:1:size(N_disp_mat,3) %Loop over time increments        
        DN=N_disp_mat(:,:,qt); %Current displacement
        DN_magnitude=sqrt(sum(DN.^2,2)); %Current displacement magnitude
        V_def=V+DN; %Current nodal coordinates
        [CF]=vertexToFaceMeasure(Fb,DN_magnitude); %Current color data to use
        
        %Set entries in animation structure
        animStruct.Handles{qt}=[hp hp]; %Handles of objects to animate
        animStruct.Props{qt}={'Vertices','CData'}; %Properties of objects to animate
        animStruct.Set{qt}={V_def,CF}; %Property values for to set in order to animate
    end        
    anim8(hf,animStruct); %Initiate animation feature    
    drawnow;
    
    %% 
    % Calculate the simulated applied uniaxial stretch
    
    DZ_set=N_disp_mat(bcPrescribeList,end,:); %Z displacements of the prescribed set
    DZ_set=mean(DZ_set,1); %Calculate mean Z displacements across nodes
    stretch_sim=(DZ_set(:)+sampleHeight)./sampleHeight; %Derive stretch
        
    %%    
    % Visualize stress-stretch curve
    
    cFigure;
    hold on;    
    title('Cauchy stress-time curve','FontSize',fontSize);
    xlabel('Time [s]','FontSize',fontSize); ylabel('\sigma Cauchy stress [Pa]','FontSize',fontSize); 
    
    plot(time_mat(:),stress_cauchy_sim(:),'r-','lineWidth',lineWidth);
    
    view(2); axis tight;  grid on; axis square; box on; 
    set(gca,'FontSize',fontSize);
    drawnow;
    
end

%% 
%
% <<gibbVerySmall.gif>>
% 
% _*GIBBON*_ 
% <www.gibboncode.org>
% 
% _Kevin Mattheus Moerman_, <gibbon.toolbox@gmail.com>
 
%% 
% _*GIBBON footer text*_ 
% 
% License: <https://github.com/gibbonCode/GIBBON/blob/master/LICENSE>
% 
% GIBBON: The Geometry and Image-based Bioengineering add-On. A toolbox for
% image segmentation, image-based modeling, meshing, and finite element
% analysis.
% 
% Copyright (C) 2019  Kevin Mattheus Moerman
% 
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.

##### SOURCE END #####
--></body></html>
